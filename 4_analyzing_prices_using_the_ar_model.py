# -*- coding: utf-8 -*-
"""4. Analyzing prices using the AR model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ll7D3_ZAT0Nd9GdewHSL0dYWxDcjPiUI

**Importando Paquetes Relevantes**

pandas (pd): Se utiliza para la manipulación y análisis de datos, incluida la gestión de DataFrames.

numpy (np): Proporciona funcionalidades para operaciones numéricas y matemáticas eficientes, lo que es útil en el procesamiento de datos y modelado.

matplotlib.pyplot (plt): Se utiliza para crear gráficos y visualizaciones de datos, lo que es esencial para representar los resultados del análisis.

statsmodels.graphics.tsaplots as sgt: Ofrece herramientas para generar gráficos relacionados con series temporales, como la función de autocorrelación (ACF) y la función de autocorrelación parcial (PACF), que son útiles para el análisis exploratorio.

statsmodels.tsa.arima.model.ARIMA: Proporciona la capacidad de ajustar modelos ARIMA (Media Móvil Integrada Autoregresiva) a datos de series temporales.

scipy.stats.distributions.chi2: Incluye la distribución chi-cuadrado, que puede ser relevante para pruebas de hipótesis en modelos estadísticos.

statsmodels.tsa.stattools as sts: Contiene herramientas estadísticas para analizar series temporales, incluyendo pruebas de estacionariedad y otras pruebas de hipótesis.

seaborn as sns: Seaborn es una biblioteca de visualización que se utiliza para mejorar la estética y legibilidad de las visualizaciones.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.graphics.tsaplots as sgt
from statsmodels.tsa.arima.model import ARIMA
from scipy.stats.distributions import chi2
import statsmodels.tsa.stattools as sts
import seaborn as sns
sns.set()

"""**Importación de datos y preprocesamiento**"""

# Cargar datos desde el archivo CSV "Index2023.csv"
df = pd.read_csv("/content/drive/MyDrive/Colab/Index2023.csv")

# Crear una copia del DataFrame para el procesamiento
df_comp = df.copy()

# Convertir la columna "date" en objetos de fecha y hora con el formato día-mes-año
df_comp.date = pd.to_datetime(df_comp.date, dayfirst=True)

# Establecer la columna "date" como el índice del DataFrame
df_comp.set_index("date", inplace=True)

# Ajustar la frecuencia de los datos a días laborables (business days)
df_comp = df_comp.asfreq('b')

# Llenar los valores faltantes utilizando el método 'ffill' (rellenado hacia adelante)
df_comp = df_comp.fillna(method='ffill')

# Crear una nueva columna "market_value" en el DataFrame df_comp con los valores de la columna "ftse"
df_comp['market_value'] = df_comp.ftse

# Eliminar columnas innecesarias del DataFrame df_comp
del df_comp['spx']
del df_comp['dax']
del df_comp['ftse']
del df_comp['nikkei']

# Calcular el tamaño del conjunto de entrenamiento como el 80% de los datos
size = int(len(df_comp) * 0.8)

# Dividir el DataFrame en conjuntos de entrenamiento y prueba
df, df_test = df_comp.iloc[:size], df_comp.iloc[size:]

"""**ACF**"""

# Crear un gráfico de la función de autocorrelación (ACF) para la serie de tiempo de "market_value"
sgt.plot_acf(df.market_value, zero=False, lags=40)
plt.title("ACF para Precios", size=20)
plt.show()

# Silenciar las advertencias para evitar su visualización durante la ejecución
import warnings
warnings.filterwarnings("ignore")

"""**PACF**"""

# Crear un gráfico de la función de autocorrelación parcial (PACF) para la serie de tiempo de "market_value"
sgt.plot_pacf(df.market_value, lags=40, alpha=0.05, zero=False, method='ols')
plt.title("PACF para Precios", size=20)
plt.show()

"""**El modelo AR (1)**"""

# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 1
model_ar = ARIMA(df.market_value, order=(1, 0, 0))

# Ajustar el modelo ARIMA y estimar los parámetros
results_ar = model_ar.fit()

# Generar un resumen de los resultados del modelo ARIMA
summary = results_ar.summary()

"""**Modelos AR con mayor retraso**"""

# Ajustar un segundo modelo ARIMA con un componente autorregresivo (AR) de orden 2
model_ar_2 = ARIMA(df.market_value, order=(2, 0, 0))
results_ar_2 = model_ar_2.fit()

# Generar un resumen de los resultados del segundo modelo ARIMA
summary_ar_2 = results_ar_2.summary()

# Ajustar un tercer modelo ARIMA con un componente autorregresivo (AR) de orden 3
model_ar_3 = ARIMA(df.market_value, order=(3, 0, 0))
results_ar_3 = model_ar_3.fit()

# Generar un resumen de los resultados del tercer modelo ARIMA
summary_ar_3 = results_ar_3.summary()

# Ajustar un cuarto modelo ARIMA con un componente autorregresivo (AR) de orden 4
model_ar_4 = ARIMA(df.market_value, order=(4, 0, 0))
results_ar_4 = model_ar_4.fit()

# Generar un resumen de los resultados del cuarto modelo ARIMA
summary_ar_4 = results_ar_4.summary()

"""**LLR Test**

La función que has definido, LLR_test, se utiliza para realizar una prueba de razón de verosimilitud (likelihood ratio test) entre dos modelos. Esta prueba compara la bondad de ajuste de dos modelos y evalúa si uno de ellos es significativamente mejor que el otro.
"""

def LLR_test(mod_1, mod_2, DF=1):
    L1 = mod_1.fit().llf
    L2 = mod_2.fit().llf
    LR = (2*(L2-L1))
    p = chi2.sf(LR, DF).round(3)
    return p

"""**Comparación de modelos AR con mayor retraso**"""

# Realizar una prueba de razón de verosimilitud (LLR) entre los modelos ARIMA model_ar_2 y model_ar_3
LLR_test(model_ar_2, model_ar_3)

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_3 y model_ar_4
LLR_result = LLR_test(model_ar_3, model_ar_4)

"""El valor 0 en una prueba de razón de verosimilitud entre dos modelos ARIMA indica que no hay evidencia estadística significativa para preferir un modelo sobre el otro en términos de ajuste a los datos de la serie de tiempo."""

# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 4
model_ar_4 = ARIMA(df.market_value, order=(4, 0, 0))
results_ar_4 = model_ar_4.fit()

# Imprimir el resumen de los resultados del modelo ARIMA
print(results_ar_4.summary())

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_3 y model_ar_4 y mostrar el resultado
LLR_result = LLR_test(model_ar_3, model_ar_4)
print("LLR test: " + str(LLR_result))

"""El modelo ARIMA(4, 0, 0) se ajustó a la serie de tiempo "market_value".
El modelo tiene un buen ajuste a los datos, como indican los valores de los criterios de información (AIC, BIC, HQIC).
Los coeficientes del modelo indican la influencia de los términos autorregresivos en la serie de tiempo.
No se encontraron evidencias significativas de autocorrelación en los residuos del modelo, ya que el valor de Prob(Q) es alto.
Los residuos del modelo no siguen una distribución normal, lo que se refleja en el valor bajo de Prob(JB).
La homocedasticidad de los residuos es adecuada, según el valor de Prob(H).
La prueba de razón de verosimilitud (LLR) con respecto al modelo anterior indica una mejora significativa en el ajuste del modelo, con un valor de LLR test igual a 0.0.
"""

# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 5
model_ar_5 = ARIMA(df.market_value, order=(5, 0, 0))
results_ar_5 = model_ar_5.fit()

# Imprimir el resumen de los resultados del modelo ARIMA
print(results_ar_5.summary())

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_4 y model_ar_5 y mostrar el resultado
LLR_result = LLR_test(model_ar_4, model_ar_5)
print("LLR test p-value = " + str(LLR_result))

"""El modelo ARIMA(5, 0, 0) se ajustó a la serie de tiempo "market_value".
El modelo tiene buen ajuste a los datos, como indican los valores de los criterios de información (AIC, BIC, HQIC).
Los coeficientes del modelo indican la influencia de los términos autorregresivos en la serie de tiempo.
No se encontraron evidencias significativas de autocorrelación en los residuos del modelo, ya que el valor de Prob(Q) es alto.
Los residuos del modelo no siguen una distribución normal, lo que se refleja en el valor bajo de Prob(JB).
La homocedasticidad de los residuos es adecuada, según el valor de Prob(H).
El valor p de la prueba de razón de verosimilitud (LLR) con respecto al modelo anterior es 0.488, lo que indica que el modelo actual no es significativamente mejor que el anterior.
"""

# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 6
model_ar_6 = ARIMA(df.market_value, order=(6, 0, 0))
results_ar_6 = model_ar_6.fit()

# Imprimir el resumen de los resultados del modelo ARIMA
print(results_ar_6.summary())

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_5 y model_ar_6 y mostrar el resultado
LLR_result = LLR_test(model_ar_5, model_ar_6)
print("LLR test p-value = " + str(LLR_result))

"""El modelo ARIMA(6, 0, 0) se ajustó a la serie de tiempo "market_value".
El modelo tiene buen ajuste a los datos, como indican los valores de los criterios de información (AIC, BIC, HQIC).
Los coeficientes del modelo indican la influencia de los términos autorregresivos en la serie de tiempo.
No se encontraron evidencias significativas de autocorrelación en los residuos del modelo, ya que el valor de Prob(Q) es alto.
Los residuos del modelo no siguen una distribución normal, lo que se refleja en el valor bajo de Prob(JB).
La homocedasticidad de los residuos es adecuada, según el valor de Prob(H).
El valor p de la prueba de razón de verosimilitud (LLR) con respecto al modelo anterior es 0.002, lo que indica que el modelo actual es significativamente mejor que el anterior.
"""

# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 7
model_ar_7 = ARIMA(df.market_value, order=(7, 0, 0))
results_ar_7 = model_ar_7.fit()

# Imprimir el resumen de los resultados del modelo ARIMA
print(results_ar_7.summary())

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_6 y model_ar_7 y mostrar el resultado
LLR_result = LLR_test(model_ar_6, model_ar_7)
print("LLR test p-value = " + str(LLR_result))

"""El modelo ARIMA(7, 0, 0) se ajustó a la serie de tiempo "market_value".
El modelo tiene buen ajuste a los datos, como indican los valores de los criterios de información (AIC, BIC, HQIC).
Los coeficientes del modelo indican la influencia de los términos autorregresivos en la serie de tiempo.
No se encontraron evidencias significativas de autocorrelación en los residuos del modelo, ya que el valor de Prob(Q) es alto.
Los residuos del modelo no siguen una distribución normal, lo que se refleja en el valor bajo de Prob(JB).
La homocedasticidad de los residuos es adecuada, según el valor de Prob(H).
El valor p de la prueba de razón de verosimilitud (LLR) con respecto al modelo anterior es 0.026, lo que indica que el modelo actual es significativamente mejor que el anterior.
"""

print("\nLLR test p-value = " + str(LLR_test(model_ar_7, model_ar_8)))
# Ajustar un modelo ARIMA con un componente autorregresivo (AR) de orden 8
model_ar_8 = ARIMA(df.market_value, order=(8, 0, 0))
results_ar_8 = model_ar_8.fit()

# Imprimir el resumen de los resultados del modelo ARIMA
print(results_ar_8.summary())

# Realizar una prueba de razón de verosimilitud (LLR) entre model_ar_7 y model_ar_8 y mostrar el resultado
print("\nLLR test p-value = " + str(LLR_test(model_ar_7, model_ar_8)))

"""El modelo se ajusta a la serie de tiempo "market_value".
Los criterios de información son útiles para evaluar el modelo.
Se presentan los coeficientes estimados del modelo.
No se encontró autocorrelación significativa en los residuos.
Los residuos no siguen una distribución normal.
La homocedasticidad de los residuos es adecuada.
La prueba de razón de verosimilitud (LLR) indica que el modelo no mejora significativamente el modelo anterior.
"""

print("LLR test: " + str(LLR_test(model_ar, model_ar_7, DF = 6)))

"""**Analizando los residuos**"""

# Calcular y agregar la columna de residuos 'res_price' al DataFrame
df['res_price'] = results_ar_7.resid

# Calcular la media de los residuos en la columna "res_price" del DataFrame df
df.res_price.mean()

"""Los residuos tienen una media de aproximadamente 0.4620024380756364. Esto sugiere que, en promedio, el modelo tiende a subestimar ligeramente la serie de tiempo, ya que los residuos tienden a ser positivos."""

# Calcular la varianza de la serie de residuos del modelo
df.res_price.var()

"""Un valor de varianza de 4026.55 en la serie de residuos de un modelo significa que los errores del modelo tienen una dispersión significativa alrededor de la serie de tiempo observada. Esta medida de dispersión indica cuánto varían los residuos en relación con su media."""

# Realizar la prueba de Dickey-Fuller aumentada en la serie de tiempo de "res_price" en el DataFrame df
sts.adfuller(df.res_price)

"""La estadística de prueba (ADF) es altamente negativa, lo que sugiere que la serie de tiempo es muy probablemente estacionaria. Este valor negativo fuertemente indica la estacionariedad de la serie.
El valor p es 0.0, lo que significa que es extremadamente bajo. Esto respalda aún más la hipótesis de que la serie es estacionaria, ya que el valor p cercano a cero indica una alta confianza en el rechazo de la hipótesis nula de no estacionariedad.
"""

# Crear un gráfico de la función de autocorrelación (ACF) de los residuos para la serie de precios
sgt.plot_acf(df.res_price, zero = False, lags = 40)
plt.title("ACF Of Residuals for Prices",size=24)
plt.show()

"""Cuando la prueba de autocorrelación (ACF) arroja un gráfico con valores cercanos a 0 en el eje vertical, significa que los residuos del modelo no muestran patrones de correlación significativos con los valores anteriores de la serie de tiempo."""

# Crear un gráfico de los residuos del modelo en la columna "res_price" del DataFrame df
df.res_price[1:].plot(figsize=(20,5))
plt.title("Residuals of Prices",size=24)
plt.show()

"""El gráfico de residuos muestra que el modelo de regresión no es adecuado para predecir el precio del producto. Esto se debe a que el modelo no tiene en cuenta todos los factores que influyen en el precio del producto, como la inflación, el tipo de interés o la oferta y la demanda del producto."""