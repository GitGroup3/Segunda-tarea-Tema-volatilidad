# -*- coding: utf-8 -*-
"""3. Working with Time Series in Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A9IpBOr0j6RLeejtSSxfGfwlYVmOWvXc

**Importando Paquetes Relevantes**
"""

# Utilidad de las bibliotecas y paquetes:
# - pandas: Para la manipulación y análisis de datos.
# - numpy: Para realizar cálculos numéricos eficientes.
# - matplotlib.pyplot: Para la creación de gráficos y visualización de datos.
# - statsmodels.graphics.tsaplots: Para crear gráficos de series temporales.
# - statsmodels.tsa.stattools: Para herramientas estadísticas en series temporales.
# - statsmodels.tsa.seasonal: Para descomposición de series temporales.
# - seaborn: Para visualización de datos.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.graphics.tsaplots as sgt
import statsmodels.tsa.stattools as sts
from statsmodels.tsa.seasonal import seasonal_decompose
import seaborn as sns
sns.set()

"""**Cargando y Transformando los Datos**"""

# Cargar datos desde un archivo CSV
df = pd.read_csv("/content/drive/MyDrive/Colab/Index2023.csv")

# Crear una copia del DataFrame
df_comp = df.copy()

# Convertir la columna "date" en objetos de fecha y hora con el formato adecuado
df_comp.date = pd.to_datetime(df_comp.date, dayfirst=True)

# Establecer la columna "date" como el índice del DataFrame
df_comp.set_index("date", inplace=True)

# Ajustar la frecuencia de los datos a días laborables (business days)
df_comp = df_comp.asfreq('b')

# Llenar los valores faltantes utilizando el método 'ffill' (rellenado hacia adelante)
df_comp = df_comp.fillna(method='ffill')

"""**Eliminando Datos Innecesarios**"""

# Crear una nueva columna "market_value" con los valores de la columna "spx"
df_comp['market_value'] = df_comp.spx

# Eliminar columnas innecesarias del DataFrame df_comp
del df_comp['spx']
del df_comp['dax']
del df_comp['ftse']
del df_comp['nikkei']

# Calcular el tamaño del conjunto de entrenamiento como el 80% de los datos
size = int(len(df_comp) * 0.8)

# Dividir el DataFrame en conjuntos de entrenamiento y prueba
df = df_comp.iloc[:size]  # Conjunto de entrenamiento
df_test = df_comp.iloc[size:]  # Conjunto de prueba

"""**Ruido Blanco**"""

# Generar una serie de números aleatorios distribuidos normalmente
# con media y desviación estándar basadas en la columna "market_value" de df
wn = np.random.normal(loc=df.market_value.mean(), scale=df.market_value.std(), size=len(df))

# Agregar una nueva columna "wn" al DataFrame df con la serie de números aleatorios
df['wn'] = wn

# Generar estadísticas descriptivas del DataFrame df
summary = df.describe()

# Crear un gráfico de la serie de tiempo de la columna "wn" en el DataFrame df
df.wn.plot(figsize=(20, 5))
plt.title("Serie Temporal de Ruido Blanco", size=24)
plt.show()

# Crear un gráfico de la serie de tiempo de la columna "market_value" en el DataFrame df
df.market_value.plot(figsize=(20, 5))
plt.title("Precios del S&P 500", size=24)
plt.ylim(0, 2300)  # Establecer el rango del eje y
plt.show()

"""**Random Walk**"""

# En esta parte se debe cargar el archivo CSV "RandWalk.csv", el cual no se encontro en la base de datos de la tarea asi que algunas partes estaran incompletas por la falta del mismo.
rw = pd.read_csv("RandWalk.csv")

# Convertir la columna "date" en objetos de fecha y hora, considerando el formato día-mes-año
rw.date = pd.to_datetime(rw.date, dayfirst=True)

# Establecer la columna "date" como el índice del DataFrame
rw.set_index("date", inplace=True)

# Ajustar la frecuencia de los datos
rw = rw.asfreq('b')

# Generar estadísticas descriptivas del DataFrame rw
summary = rw.describe()

# Mostrar las primeras filas del DataFrame df
df.head()

"""**Estacionariedad**"""

# Realizar la prueba de Dickey-Fuller aumentada en la serie de tiempo de "market_value" en el DataFrame df
sts.adfuller(df.market_value)

"""La prueba se utiliza para determinar si una serie temporal es estacionaria o no. Los resultados indican que la serie es estacionaria debido a un valor de estadístico negativo (-70.53), un valor p muy bajo (0.0), y la comparación favorable con valores críticos. Esto sugiere que no hay evidencia de tendencia o no estacionariedad en la serie temporal."""

# Realizar la prueba de Dickey-Fuller aumentada en la serie de tiempo de "wn" en el DataFrame df
sts.adfuller(df.wn)

"""Los resultados de la prueba indican fuertemente que la serie temporal es estacionaria. El estadístico ADF extremadamente negativo y el valor p de 0.0 respaldan esta conclusión, y el estadístico es mucho menor que los valores críticos en todos los niveles de significancia. La serie es probablemente estacionaria en este caso.

**Estacionalidad**
"""

# Realizar descomposición estacional en la serie de tiempo de "market_value" con un modelo multiplicativo
s_dec_multiplicative = seasonal_decompose(df.market_value, model="multiplicative")

# Mostrar el gráfico de la descomposición estacional
s_dec_multiplicative.plot()
plt.show()

"""**ACF**"""

# Crear un gráfico de la función de autocorrelación (ACF) de la serie de tiempo de "market_value"
sgt.plot_acf(df.market_value, lags = 40, zero = False)
plt.title("ACF S&P", size = 24)
plt.show()

"""El gráfico muestra la función de autocorrelación (ACF) del índice S&P 500. La ACF es una medida de la correlación entre los valores de una serie de tiempo y sus valores retrasados.
En este caso, la ACF muestra que el índice S&P 500 tiene una correlación positiva con sus valores retrasados de hasta 5 días. Esto significa que los valores del índice S&P 500 tienden a moverse en la misma dirección durante un período de 5 días.
La ACF también muestra que la correlación disminuye a medida que aumenta el retraso. Esto significa que la relación entre los valores del índice S&P 500 y sus valores retrasados se debilita con el tiempo.

**PACF**
"""

# Crear un gráfico de la función de autocorrelación parcial (PACF) de la serie de tiempo de "market_value"
sgt.plot_pacf(df.market_value, lags = 40, zero = False, method = ('ols'))
plt.title("PACF S&P", size = 24)
plt.show()

"""La serie de tiempo tiene una tendencia ascendente débil, debido a la autocorrelación de primer orden significativa. El patrón PACF indica un término autorregresivo de orden 1. Este subtítulo adicional proporciona información adicional sobre el patrón que se observa en el gráfico PACF. El patrón de una correlación significativa en el desfase 1 seguida de correlaciones que no son significativas es un patrón característico de un término autorregresivo de orden 1."""

# Crear un gráfico de la función de autocorrelación parcial (PACF) de la serie de tiempo de "wn"
sgt.plot_pacf(df.wn, lags = 40, zero = False, method = ('ols'))
plt.title("PACF WN", size = 24)
plt.show()

"""Este patrón es típico de una serie de tiempo que tiene una tendencia. En el caso de la serie de tiempo representada en la imagen, la tendencia es el ritmo de la ola. El hecho de que el valor actual de la serie de tiempo esté más fuertemente correlacionado con el valor anterior de la serie de tiempo indica que el ritmo de la ola actual está influenciado por el ritmo de la ola anterior.
El patrón observado en el gráfico PACF indica que un término autorregresivo de orden 1 (AR(1)) podría ser un modelo adecuado para esta serie de tiempo. Un modelo AR(1) asume que el valor actual de la serie de tiempo es una combinación lineal del valor anterior de la serie de tiempo y una componente aleatoria.
"""